
```kotlin
suspend fun main(): Unit = coroutineScope {
	launch {
		delay(1000)
		println("World")
	}
	println("Hello, ")
}
// Hello
// (1 sec)
// World
```

Функция `coroutineScope` создает область видимости из приостанавливающего контекста.
Он наследует область действия от своего родителя и поддерживает структурированный параллелизм.
Что бы было понятно, между приведенными ниже функциям и практически нет разницы , за исключением того, что первая вызывает `getProfile` и `getFriends` последовательно, а вторая вызывает их одновременно.

```kotlin
suspend fun produceCurrentUserSeq(): User {
	val profile = repo.getProfile() 
	val friends = repo.getFriends()
	return User(profile, friends)
}

suspend fun produceCurrentUserSym(): User = coroutineScope {
	val profile = async { repo.getProfile() } 
	val friends = async { repo.getFriends() }
	User(profile.await(), friends.await())
}
```
`coroutineScope` полезная функция, но не единственная в своем роде.
## Функции области сопрограммы

Есть и другие функции, которые создают `coroutineScope` и ведут себя аналогичным образом.
`supervisorScope` похож на `coroutineScope`, но вместо `Job` использует `SupervisorJob`. `withContext`  — это `coroutineScope`, который может изменять контекст сопрограммы. `withTimeout` — это `coroutineScope` с таймаутом.

## withContext

Функция `withContext` похожа на `coroutineScope`, но дополнительно позволяет вносить некоторые изменения в область видимости. Контекст, предоставленный в качестве аргумента этой функции, переопределяет контекст родительской `scope` (так же, как и в построителях сопрограмм). Это означает, что `withContext(EmptyCoroutineContext)` и `coroutineScope()` ведут себя одинаково.

```kotlin
fun CoroutineScope.log(text: String) {
	val name = this.coroutineContext[CoroutineName]?.name
	println("[$name] $text")
}

fun main() = runBlocking(CoroutineName("Parent")) {
	log("Before")
	
	withContext(CoroutineName("Child 1")) {
		delay(1000)
		log("Hello 1")
	}

	withContext(CoroutineName("Child 2")) {
		delay(1000)
		log("Hello 2")
	}
	
	log("After")
}

// [Parent] Before
// (1 sec)
// [Child 1] Hello 1
// (1 sec)
// [Child 2] Hello 2
// [Parent] After
```

Функция `withContext` часто используется для установки другой области действия сопрограммы для части нашего кода. Обычно его следует использовать вместе с диспетчерами, как будет описано в следующей главе.

```kotlin
launch(Dispatchers.Main) {
	view.showProgressBar()
	withContext(Dispatchers.IO) {
		fileRepository.saveData(data)
	}
	view.hideProgressBar()
}
```

Вы могли заметить, что принцип работы `coroutineScope { /*...*/ }` очень похож на async с немедленным ожиданием: `async { /*...*/ }.await()`. Также `withContext(context) { /*...*/ }` чем-то похож на` async(context) { /*...*/ }.await()`. Самая большая разница заключается в том, что для `async` требуется область действия, а `coroutineScope` и `withContext` выводят область из приостановки. В обоих случаях лучше использовать `coroutineScope` и `withContext` и избегать асинхронности с немедленным `await`.

## supervisorScope

Функция `SupervisorScope` также во многом похожа на `coroutineScope`: она создает `CoroutineScope`, который наследуется от внешней области видимости, и вызывает в ней указанный блок приостановки. Разница в том, что он переопределяет `Job` контекста с помощью `SupervisorJob`, поэтому он не отменяется, когда дочерний элемент вызывает исключение.

```kotlin
fun main() = runBlocking {

	println("Before")
	
	supervisorScope {
		launch {
			delay(1000)
			throw Error()
		}

		launch {
			delay(2000)
			println("Done")
		}
	}
                                                     
	println("After")
}

// Before
// (1 sec)
// Exception...
// (1 sec)
// Done
// After
```

`SupervisorScope` в основном используется в функциях, которые запускают несколько независимых задач.

```kotlin
suspend fun notifyAnalytics(actions: List<UserAction>) =
	supervisorScope {
		actions.forEach { action ->
			launch {
				notifyAnalytics(action)
			}
		}
	}
```

Если вы используете `async`, подавления распространения исключений родительскому элементу недостаточно. Когда мы вызываем `await` и асинхронная сопрограмма завершается с исключением, `await` выдает его повторно. Вот почему, если мы хотим по-настоящему игнорировать исключения, нам также следует обернуть вызовы `await` блоком `try-catch`

```kotlin
class ArticlesRepositoryComposite(
	private val articleRepositories: List<ArticleRepository>,
) : ArticleRepository {

	override suspend fun fetchArticles(): List<Article> =
		supervisorScope {
			articleRepositories
			.map { async { it.fetchArticles() } }
			.mapNotNull {
				try {
					it.await()
				} catch (e: Throwable) {
					e.printStackTrace()
					null
				}
			}
			.flatten()
			.sortedByDescending { it.publishedAt }
	}
	
}
```

На моих семинарах меня часто спрашивают, можем ли мы использовать
`withContext(SupervisorJob())` вместо `supervisorScope`. Нет,
мы не можем. Когда мы используем `withContext(SupervisorJob())`, тогда
`withContext` по-прежнему использует обычное задание, а `SupervisorJob()`
становится его родителем. В результате, когда один ребенок вызывает исключение,
остальные дети также будут отменены. `withContext` также будет
выдать исключение, поэтому его `SupervisorJob()` практически бесполезен.
Вот почему я считаю `withContext(SupervisorJob())` бессмысленным и
вводит в заблуждение, и я считаю это плохой практикой.

```kotlin
fun main() = runBlocking {
	println("Before")
	withContext(SupervisorJob()) {
		launch {
			delay(1000)
			throw Error()
		}
		launch {
			delay(2000)
			println("Done")
		}
	}
	println("After")
}
// Before
// (1 sec)
// Exception...
```

## withTimeout

Еще одна функция, которая во многом похожа на `coroutineScope`.
есть `withTimeout`. Он также создает область действия и возвращает значение.
На самом деле, `withTimeout` с очень большим таймаутом ведет себя так же, как
`coroutineScope`. Разница в том, что `withTimeout` дополнительно устанавливает
срок исполнения его тела. Если это занимает слишком много времени, оно отменяется
 и выдает исключение `TimeoutCancellationException` (подтип
`CancellationException`).

```kotlin
suspend fun test(): Int = withTimeout(1500) {
	delay(1000)
	println("Still thinking")
	delay(1000)
	println("Done!")
	42
}

suspend fun main(): Unit = coroutineScope {
	try {
		test()
	} catch (e: TimeoutCancellationException) {
		println("Cancelled")
	}
	delay(1000) // Extra timeout does not help,
	// `test` body was cancelled
}
// (1 sec)
// Still thinking
// (0.5 sec)
// Cancelled
```

Функция `withTimeout` особенно полезна для тестирования. Может быть
используется для проверки того, занимает ли какая-то функция больше или меньше некоторого времени. Если он используется внутри `runTest` и будет работать в виртуальном времени. Мы также используем его внутри `runBlocking`, чтобы просто ограничить время выполнения некоторой функции (это похоже на установку тайм-аута в `@Test`).

```kotlin
class Test {
	@Test
	fun testTime2() = runTest {
		withTimeout(1000) {
			// something that should take less than 1000
			delay(900) // virtual time
		}
	}
	
	@Test(expected = TimeoutCancellationException::class)
	fun testTime1() = runTest {
		withTimeout(1000) {
		// something that should take more than 1000
		delay(1100) // virtual time
		}
	}
	
	@Test
	fun testTime3() = runBlocking {
		withTimeout(1000) {
		// normal test, that should not take too long
		delay(900) // really waiting 900 ms
		}
	}
}
```

Помните, что `withTimeout` выдает исключение `TimeoutCancellationException`,
которое является подтипом `CancellationException` (то же самое исключение
который выдается при отмене сопрограммы). Итак, когда это
исключение выбрасывается в сборщике сопрограмм, оно только отменяет его и
не влияет на своего родителя (как объяснялось в предыдущей главе).

```kotlin
suspend fun main(): Unit = coroutineScope {
	launch { // 1
		launch { // 2, cancelled by its parent
			delay(2000)
			println("Will not be printed")
		}
		
		withTimeout(1000) { // we cancel launch
			delay(1500)
		}
	}
	
	launch { // 3
		delay(2000)
		println("Done")
	}
}
// (2 sec)
// Done
```

В приведенном выше примере задержка (1500) занимает больше времени, чем
withTimeout(1000) ожидает, throws TimeoutCancellationException.
Исключение перехватывается при запуске с 1, и оно отменяет себя и свое
дети, поэтому запуск с 2. запуск начатый с 3 тоже не влияет.
Менее агрессивный вариант `withTimeout` — `withTimeoutOrNull`, который
не генерирует исключение. Если тайм-аут превышен, это просто
это просто отменяет свое тело и возвращает `null`. `withTimeoutOrNull` полезен для
функции-обертки, в которых время ожидания слишком велико что что-то пошло не так. Например, сетевые операции: если мы подождите более 5 секунд ответа, вряд ли мы его когда-нибудь получим это (некоторые библиотеки могут ждать вечно).

```kotlin
suspend fun fetchUser(): User {
	// Runs forever
	while (true) {
		yield()
	}
}
suspend fun getUserOrNull(): User? =
	withTimeoutOrNull(5000) {
	fetchUser()
	}
	
suspend fun main(): Unit = coroutineScope {
	val user = getUserOrNull()
	println("User: $user")
}
// (5 sec)
// User: null
```

## Connecting coroutine scope functions

Если вам нужно использовать функции из двух функций области сопрограммы,
вам нужно использовать одно внутри другого. Например, чтобы установить оба
тайм-аут и диспетчер, вы можете использовать `withTimeoutOrNull` внутри
`withContext`.

```kotlin
suspend fun calculateAnswerOrNull(): User? =
	withContext(Dispatchers.Default) {
		withTimeoutOrNull(1000) {
		calculateAnswer()
		}
	}
```

## Additional operations

Представьте себе случай, когда в середине какой-то обработки вам нужно
выполнить дополнительную операцию. Например, после показа профиль пользователя, которому вы хотите отправить запрос в целях аналитики. Люди часто делают это с помощью обычного `launch` в той же области:

```kotlin
class ShowUserDataUseCase(
	private val repo: UserDataRepository,
	private val view: UserDataView,
) {
	suspend fun showUserData() = coroutineScope {
		val name = async { repo.getName() }
		val friends = async { repo.getFriends() }
		val profile = async { repo.getProfile() }
		val user = User(
			name = name.await(),
			friends = friends.await(),
			profile = profile.await()
		)
		view.show(user)
		launch { repo.notifyProfileShown() }
	}
}
```

Однако с этим подходом есть некоторые проблемы. Во-первых, это
`launch` здесь ничего не делает, потому что `coroutineScope` должен дождаться своего
завершение в любом случае. Итак, если вы показываете индикатор выполнения при включении датируя представление, пользователю нужно дождаться этого notifyProfileShown
тоже закончено. Это не имеет особого смысла.

```kotlin
fun onCreate() {
	viewModelScope.launch {
		_progressBar.value = true
		showUserData()
		_progressBar.value = false
	}
}
```

Вторая проблема – отмена. Сопрограммы разработаны (разработчиком
default) для отмены других операций при возникновении исключения. Этот
отлично подходит для важных операций. Если в `getProfile` есть исключение, мы
следует отменить `getName` и `getFriends`, потому что их ответ будет
все равно быть бесполезным. Однако отмена процесса только потому, что
вызов аналитики не удался, не имеет особого смысла.
так что нам делать? Если у вас есть дополнительный (несущественный)
операцию, которая не должна влиять на основной процесс, лучше
запустите его в отдельной области. Создать свою собственную scope легко. В этом
Например, мы создаем `AnalyticsScope`.

```kotlin
val analyticsScope = CoroutineScope(SupervisorJob())
```

Для модульного тестирования и управления этой областью лучше внедрить ее через
конструктор:

```kotlin
class ShowUserDataUseCase(
	private val repo: UserDataRepository,
	private val view: UserDataView,
	private val analyticsScope: CoroutineScope,
) {
	suspend fun showUserData() = coroutineScope {
		val name = async { repo.getName() }
		val friends = async { repo.getFriends() }
		val profile = async { repo.getProfile() }
		val user = User(
			name = name.await(),
			friends = friends.await(),
			profile = profile.await()
		)
		view.show(user)
		analyticsScope.launch { repo.notifyProfileShown() }
	}
}
```

Запуск операций над введенным объектом области является обычным явлением. Прохождение область видимости ясно сигнализирует о том, что такой класс может запускать независимые вызовы.
Это означает, что приостановка функций может не дождаться завершения всех операций.
они начинают. Если область действия не передана, мы можем ожидать, что приостановка
функции не завершатся, пока не будут выполнены все их операции.

Функции области действия сопрограмм действительно полезны, особенно потому, что они могут использоваться в любой приостанавливающей функции. Чаще всего их используют для обертывания все тело функции. Хотя их часто используют просто для обертывания
куча вызовов с областью видимости (особенно с контекстом), надеюсь, вы
можно оценить их полезность. Они являются очень важной частью
экосистема Kotlin Coroutines. Вы увидите, как мы их будем использовать
через остальную часть книги.