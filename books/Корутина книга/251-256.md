## Select

Корутины предоставляют функцию `select`, которая позволяет ожидать результат первой завершившейся корутины. Она также предоставляет возможность отправить данные в первый канал, у которого есть свободное место в буфере, или получить данные из первого канала, у которого есть доступный элемент. Это позволяет устраивать состязания между корутинами или объединять результаты из нескольких источников. Давайте посмотрим на практике, как это работает.

Функция `select` все еще находится в экспериментальном статусе, хотя данная функциональность доступна с начала релизов Kotlin Coroutines. Вряд ли `select` будет удален, но его API все еще может измениться. Эта функция, скорее всего, никогда не будет стабилизирована, потому что спрос на нее довольно мал - она используется довольно редко, поэтому я решил сделать эту главу как можно более краткой.

## Выбор отложенных значений

Давайте предположим, что мы хотим запросить данные из нескольких источников, но нас интересует только самый быстрый ответ. Самый простой способ это сделать - запустить эти запросы в асинхронных процессах, а затем использовать функцию `select` в качестве выражения и дождаться различных значений внутри неё. Внутри `select` мы можем вызвать `onAwait` на отложенном значении (Deferred value), которое определяет возможный результат выражения `select`. Внутри лямбда-выражения вы можете преобразовать это значение. В приведенном ниже примере мы просто возвращаем результат асинхронной задачи, поэтому выражение `select` завершится, как только завершится первая асинхронная задача, и затем вернет её результат.

```kotlin
suspend fun requestData1(): String {
	delay(100_000)
	return "Data1"
}

suspend fun requestData2(): String {
	delay(1000)
	return "Data2"
}

val scope = CoroutineScope(SupervisorJob())

suspend fun askMultipleForData(): String {
	val defData1 = scope.async { requestData1() }
	val defData2 = scope.async { requestData2() }
	return select {
		defData1.onAwait { it }
		defData2.onAwait { it }
	}
}

suspend fun main(): Unit = coroutineScope {
	println(askMultipleForData())
}
// (1 sec)
// Data2
```
Заметьте, что `async` в приведенном выше примере должен быть запущен во внешней области видимости. Это означает, что если вы отмените корутину, которая запустила `askMultipleForData`, эти асинхронные задачи не будут отменены. Это проблема, но я не знаю более эффективной реализации. Если бы мы использовали `coroutineScope`, то он ожидал бы завершения своих дочерних задач; поэтому для приведенной ниже реализации мы все равно получим `receiveData2`, но уже через 100 секунд, а не через одну.
```kotlin
// ...

suspend fun askMultipleForData(): String {
	val defData1 = scope.async { requestData1() }
	val defData2 = scope.async { requestData2() }
	return select<String> {
		defData1.onAwait { it }
		defData2.onAwait { it }
	}
}

suspend fun main(): Unit = coroutineScope {
	println(askMultipleForData())
}
// (100 sec)
// Data2
```

Для эффективной реализации состязания корутин можно использовать `async` и `select`, однако потребуется явная отмена области видимости. Мы могли бы отменить другие корутины в блоке `also`, который вызывается после того, как `select` произведет значение.

```kotlin
suspend fun askMultipleForData(): String = coroutineScope {
	select<String> {
		async { requestData1() }.onAwait { it }
		async { requestData2() }.onAwait { it }
	}.also { coroutineContext.cancelChildren() }
}

suspend fun main(): Unit = coroutineScope {
	println(askMultipleForData())
}
// (1 sec)
// Data2
```

Решение, представленное выше, немного сложно, поэтому многие разработчики создают вспомогательные функции или используют внешние библиотеки (например, Splitties от Louis CAD), которые включают функцию `raceOf`. Такая функция может быть определена всего в нескольких строках, как я покажу в главе "Recipes".

```kotlin
// Implementation using raceOf from Splitties library
suspend fun askMultipleForData(): String = raceOf({
	requestData1()
}, {
	requestData2()
})

suspend fun main(): Unit = coroutineScope {
	println(askMultipleForData())
}
// (1 sec)
// Data2
```

## Selecting from channels

Функция `select` также может быть использована с каналами. Вот основные функции, которые можно использовать внутри неё:

• `onReceive` - выбирается, когда в канале есть значение. Он получает это значение (как метод receive) и использует его в качестве аргумента для своего лямбда-выражения. Когда выбирается `onReceive`, `select` возвращает результат своего лямбда-выражения. 
• `onReceiveCatching` - выбирается, когда в канале есть значение или канал закрыт. Он получает `ChannelResult`, который либо представляет значение, либо сигнализирует о том, что канал закрыт, и использует это значение в качестве аргумента своего лямбда-выражения. Когда выбирается `onReceiveCatching`, `select` возвращает результат своего лямбда-выражения. 
• `onSend` - выбирается, когда в канале есть место в буфере. Он отправляет значение в этот канал (как метод send) и вызывает своё лямбда-выражение с ссылкой на канал. Когда выбирается `onSend`, `select` возвращает `Unit`.

Давайте рассмотрим некоторые практические применения. Выражение `select` может быть использовано с `onReceive` или `onReceiveCatching` для получения данных из нескольких каналов.

```kotlin
suspend fun CoroutineScope.produceString(
	s: String,
	time: Long
) = produce {
	while (true) {
		delay(time)
		send(s)
	}
}

fun main() = runBlocking {
	val fooChannel = produceString("foo", 210L)
	val barChannel = produceString("BAR", 500L)

	repeat(7) {
		select {
			fooChannel.onReceive {
				println("From fooChannel: $it")
			}
			barChannel.onReceive {
				println("From barChannel: $it")
			}
		}
	}
	coroutineContext.cancelChildren()
}
// From fooChannel: foo
// From fooChannel: foo
// From barChannel: BAR
// From fooChannel: foo
// From fooChannel: foo
// From barChannel: BAR
// From fooChannel: foo
```

Функцию `select` можно использовать с `onSend`, чтобы отправить данные в первый канал, у которого есть место в буфере.

```kotlin
fun main(): Unit = runBlocking {
	val c1 = Channel<Char>(capacity = 2)
	val c2 = Channel<Char>(capacity = 2)

	// Send values
	launch {
		for (c in 'A'..'H') {
			delay(400)
			select<Unit> {
				c1.onSend(c) { println("Sent $c to 1") }
				c2.onSend(c) { println("Sent $c to 2") }
			}
		}
	}

	// Receive values
	launch {
		while (true) {
			delay(1000)
			val c = select<String> {
				c1.onReceive { "$it from 1" }
				c2.onReceive { "$it from 2" }
			}
			println("Received $c")
		}
	}
}
// Sent A to 1
// Sent B to 1
// Received A from 1
// Sent C to 1
// Sent D to 2
// Received B from 1
// Sent E to 1
// Sent F to 2
// Received C from 1
// Sent G to 1
// Received E from 1
// Sent H to 1
// Received G from 1
// Received H from 1
// Received D from 2
// Received F from 2
```

## Резюме 

`select` - полезная функция, которая позволяет ожидать результат первой завершившейся корутины, отправлять или получать данные из первого из нескольких каналов. Она в основном используется для реализации различных шаблонов работы с каналами, но также может быть использована для организации async гонки между корутинами.