## Hot and cold data sources

Изначально в Kotlin Coroutines был только Channel, но разработчики заметили, что иногда это недостаточно. Каналы представляют собой `горячий` поток значений, который активен и передает данные независимо от того, нужны они или нет. Однако часто требуется `холодный` поток, который генерирует или передает данные только в ответ на запрос или подписку на эти данные. Именно для таких случаев был введен в Kotlin Coroutines поток данных (`Flow`), предоставляющий более гибкий и управляемый подход к потокам данных.

Понимание разницы между "горячими" и "холодными" потоками данных полезно для разработчика, поскольку большинство источников данных, с которыми вы работаете ежедневно, попадают в одну из этих двух категорий. Коллекции (`List`, `Set` и т.д.) являются "горячими", в то время как `Sequence` и Java `Stream` являются "холодными". Канал (Channel) является "горячим", в то время как поток данных (Flow) и потоки в RxJava (Observable, Single и т.д.) являются "холодными".

## Hot vs cold

Горячие потоки данных работают "быстро", производя элементы независимо от их потребления, и хранят сгенерированные элементы. Холодные потоки данных же работают "лениво" – выполняют свои операции по мере необходимости и ничего не хранят.

Эти различия очевидны при работе с коллекциями (горячие) и последовательностями (холодные). Построители и операции с горячими потоками данных начинают выполнение немедленно. В холодных потоках данных они не запускаются до тех пор, пока элементы не понадобятся.

```kotlin
fun main() {
	val l = buildList {
	repeat(3) {
		add("User$it")
		println("L: Added User")
	}
}

val l2 = l.map {
	println("L: Processing")
	"Processed $it"
}

val s = sequence {
	repeat(3) {
		yield("User$it")
		println("S: Added User")
	}
}

val s2 = s.map {
	println("S: Processing")
	"Processed $it"
}

}
// L: Added User
// L: Added User
// L: Added User
// L: Processing
// L: Processing
// L: Processing
//sampleEnd
```

В результате холодные потоки данных (такие как Sequence, Stream или Flow):

• могут быть бесконечными; 
• выполняют минимальное количество операций;
• используют меньше памяти (нет необходимости выделять все промежуточные коллекции).

Обработка `Sequence` выполняет меньше операций, потому что обрабатывает элементы лениво. Её работа очень проста. Каждая промежуточная операция (например, `map` или filter) `просто` декорирует предыдущую последовательность новой операцией. Терминальная операция⁴⁹ выполняет всю работу.

Давайте рассмотрим пример. В случае последовательности операция `find` запрашивает результат `map` для первого элемента. Она запрашивает последовательность, возвращенную из `sequenceOf` (возвращает 1), затем `maps` её (в 1) и возвращает её в `filter`. `filter` проверяет, удовлетворяет ли этот элемент его критериям. Если элемент не удовлетворяет критериям, `filter` запрашивает снова и снова, пока не будет найден подходящий элемент.

Это очень отличается от обработки списков, которая на каждом промежуточном шаге вычисляет и возвращает полностью обработанную коллекцию. Именно поэтому порядок обработки элементов различается, а обработка коллекций занимает больше памяти и может потребовать больше операций (как в приведенном ниже примере).

```kotlin
fun m(i: Int): Int {
	print("m$i ")
	return i * i
}

fun f(i: Int): Boolean {
	print("f$i ")
	return i >= 10
}

fun main() {
	listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
		.map { m(it) }
		.find { f(it) }
		.let { print(it) }
	// m1 m2 m3 m4 m5 m6 m7 m8 m9 m10 f1 f4 f9 f16 16
	println()

	sequenceOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
		.map { m(it) }
		.find { f(it) }
		.let { print(it) }
	// m1 f1 m2 f4 m3 f9 m4 f16 16
}
```

Это означает, что список является коллекцией элементов, в то время как последовательность (sequence) представляет собой просто определение того, как эти элементы должны быть вычислены. Горячие потоки данных:

• всегда готовы к использованию (каждая операция может быть терминальной); 
• не нужно пересчитывать результат при множественном использовании.

```kotlin
fun m(i: Int): Int {
	print("m$i ")
	return i * i
}

fun main() {
	val l = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
		.map { m(it) } // m1 m2 m3 m4 m5 m6 m7 m8 m9 m10

	println(l) // [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
	println(l.find { it > 10 }) // 16
	println(l.find { it > 10 }) // 16
	println(l.find { it > 10 }) // 16

	val s = sequenceOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
		.map { m(it) }

	println(s.toList())
	// [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
	println(s.find { it > 10 }) // m1 m2 m3 m4 16
	println(s.find { it > 10 }) // m1 m2 m3 m4 16
	println(s.find { it > 10 }) // m1 m2 m3 m4 16
}
```

Java `Stream` имеет общие характеристики с `Sequence` Kotlin. Они есть оба холодные потоки значений.

## Hot channels, cold flow

Пора вернуться к корутинам. Самый типичный способ создания потока данных (`Flow`) - использование конструктора, который похож на функцию `produce`. Он называется `flow`.

```kotlin
val channel = produce {
	while (true) {
		val x = computeNextValue()
		send(x)
	}
}

val flow = flow {
	while (true) {
		val x = computeNextValue()
		emit(x)
	}
}
```

Эти конструкторы концептуально эквивалентны, но поскольку поведение каналов (`channel`) и потоков данных (`flow`) очень различается, между этими двумя функциями также существуют важные различия. Взгляните на приведенный ниже пример. Каналы являются "горячими", поэтому они немедленно начинают вычисление значений. Это вычисление запускается в отдельной корутине. Вот почему функция `produce` должна быть построителем корутины, определенной как расширение на `CoroutineScope`. Расчет начинается немедленно, но поскольку размер буфера по умолчанию равен 0 (`rendezvous`), он скоро будет приостановлен, пока получатель не будет готов принять данные в приведенном ниже примере. Обратите внимание, что есть разница между остановкой производства при отсутствии получателя и производством по требованию. Каналы, как "горячие" потоки данных, производят элементы независимо от их потребления и затем сохраняют их. Они не обращают внимания на количество получателей. Поскольку каждый элемент можно получить только один раз, после того как первый получатель потребит все элементы, второй обнаружит, что канал пуст и уже закрыт. Вот почему он не получит ни одного элемента.

```kotlin
private fun CoroutineScope.makeChannel() = produce {
	println("Channel started")
	for (i in 1..3) {
		delay(1000)
		send(i)
	}
}

suspend fun main() = coroutineScope {
	val channel = makeChannel()
	
	delay(1000)
	println("Calling channel...")
	for (value in channel) {
		println(value)
	}
	println("Consuming again...")
	for (value in channel) {
		println(value)
	}
}
// Channel started
// (1 sec)
// Calling channel...
// 1
// (1 sec)
// 2
// (1 sec)
// 3
// Consuming again...
```

Обработка с использованием `Flow` сильно отличается. Поскольку это холодный источник данных, производство происходит по запросу. Это означает, что flow не является построителем и не выполняет никаких операций. Он лишь определяет, как элементы должны быть произведены и будет использован только при использовании терминальной операции (например, `collect`). Поэтому конструктор flow не требует `CoroutineScope`. Он будет выполняться в области видимости терминальной операции, которая его вызвала (получает область видимости из продолжения ожидающей функции, как и другие функции области видимости корутины).

Каждая терминальная операция с потоком данных (Flow) начинает обработку с нуля. Сравните приведенные выше и ниже примеры, потому что они демонстрируют основные различия между Channel и Flow.

```kotlin
private fun makeFlow() = flow {
	println("Flow started")
	for (i in 1..3) {
		delay(1000)
		emit(i)
	}
}

suspend fun main() = coroutineScope {
	val flow = makeFlow()

	delay(1000)
	println("Calling flow...")
	flow.collect { value -> println(value) }
	println("Consuming again...")
	flow.collect { value -> println(value) }
}
// (1 sec)
// Calling flow...
// Flow started
// (1 sec)
// 1
// (1 sec)
// 2
// (1 sec)
// 3
// Consuming again...
// Flow started
// (1 sec)
// 1
// (1 sec)
// 2
// (1 sec)
// 3
```

RxJava streams и потоки данных (Flow) в Kotlin имеют много общих характеристик. Некоторые даже говорят, что Flow можно было бы назвать "RxCoroutines".

## Резюме

Большинство источников данных могут быть либо "горячими", либо "холодными":

• "Горячие" источники данных активны. Они производят элементы как можно скорее и сохраняют их. Эти элементы производятся независимо от их потребления. К ним относятся коллекции (List, Set) и Channel. 
• "Холодные" источники данных ленивы. Они обрабатывают элементы по требованию на терминальной операции. Все промежуточные функции лишь определяют, что должно быть сделано (чаще всего с использованием паттерна Декоратор). Они, как правило, не сохраняют элементы и создают их по мере необходимости. Они выполняют минимальное количество операций и могут быть бесконечными. К ним относятся Sequence, Java Stream, Flow и RxJava streams (Observable, Single и т.д.).

Это объясняет основное различие между Channel и Flow. Теперь пришло время обсудить все различные функции, поддерживаемые последним.