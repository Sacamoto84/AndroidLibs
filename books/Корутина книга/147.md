# Dispatchers

Важный функционал, предлагаемый библиотекой Kotlin Coroutines.
позволяет нам решить, в каком потоке (или пуле потоков) будет использоваться сопрограмма
должен работать (запускаться и возобновляться). Это делается с помощью диспатчеры.
В сопрограммах Котлина `CoroutineContext` определяет, в каком потоке находится определенная сопрограмма работать.


## Default dispatcher

Если вы не установили какой-либо диспетчер, по умолчанию будет выбран тот, который
`Dispatchers.Default`, предназначенный для работы с интенсивным использованием ЦП
операции. Он имеет пул потоков размером, равным числу ядер на машине, на которой работает ваш код (но не менее два). По крайней мере теоретически это оптимальное количество потоков, предполагая, что вы эффективно используете эти потоки, т. е. выполняете вычисления с интенсивным использованием ЦП и отсутствие их блокировки.
Чтобы увидеть этот диспетчер в действии, запустите следующий код:

```kotlin
suspend fun main() = coroutineScope {
	repeat(1000) {
		launch { // or launch(Dispatchers.Default) {
			// To make it busy
			List(1000) { Random.nextLong() }.maxOrNull()
			val threadName = Thread.currentThread().name
			println("Running on thread: $threadName")
		}
	}
}
```

Пример результата на моей машине (у меня 12 ядер, поэтому их 12
потоки в пуле):

Running on thread: DefaultDispatcher-worker-1
Running on thread: DefaultDispatcher-worker-5
Running on thread: DefaultDispatcher-worker-7
Running on thread: DefaultDispatcher-worker-6
Running on thread: DefaultDispatcher-worker-11
Running on thread: DefaultDispatcher-worker-2
Running on thread: DefaultDispatcher-worker-10
Running on thread: DefaultDispatcher-worker-4
...

Предупреждение: `runBlocking` устанавливает свой собственный диспетчер, если нет другого.
один установлен; поэтому внутри него` Dispatcher.Default` не является
тот, который выбирается автоматически. Итак, если бы мы использовали
`runBlocking` вместо `coroutineScope` в приведенном выше примере
Например, все сопрограммы будут работать на `«main»`.


## Ограничение диспетчера по умолчанию

Допустим, у вас есть дорогостоящий процесс, и вы подозреваете, что
он может использовать все потоки `Dispatcher.Default` и морить голодом другие
сопрограммы, использующие тот же диспетчер. В таких случаях мы можем использовать
ограниченный параллелизм в диспетчерах. По умолчанию для создания диспетчера
который работает в тех же потоках, но ограничен использованием не более
определенное их количество одновременно.

```kotlin
private val dispatcher = Dispatchers.Default
	.limitedParallelism(5)
```

Этот механизм используется для того, чтобы не ограничивать `Dispatchers.Default`.
но стоит об этом помнить, ведь скоро мы представим ограниченный параллелизм для `Dispatchers.IO`, что гораздо больше важное и обычное.

## Main dispatcher

В Android и многих других платформах приложений существует концепция
основной поток или поток пользовательского интерфейса, который обычно является самым важным потоком.

На Android это единственный инструмент, который можно использовать для взаимодействия с UI. Поэтому его нужно использовать очень часто, но и с большой осторожностью.
Когда основной поток блокируется, все приложение зависает. К запускаем сопрограмму в основном потоке, мы используем `Dispatchers.Main`.

`Dispatchers.Main` доступен на Android, если мы используем `Kotlinx-coroutines-android` артефакт. Аналогично, он доступен на JavaFX, если мы используем kotlinx-coroutines-javafx, и на Swing, если мы используем kotlinx-coroutines-swing. Если у вас нет зависимости определяющий главного диспетчера, он недоступен и не может быть использован.

Обратите внимание, что библиотеки внешнего интерфейса обычно не используются в модульных тестах, поэтому `Dispatchers.Main` там не определен. Чтобы иметь возможность использовать его, вам необходимо установить диспетчер с помощью Dispatchers.setMain(dispatcher) из kotlinx-coroutines-test.

```kotlin
class SomeTest {

	private val dispatcher = Executors
		.newSingleThreadExecutor()
		.asCoroutineDispatcher()
		
	@Before
	fun setup() {
		Dispatchers.setMain(dispatcher)
	}
	
	@After
	fun tearDown() {
		// reset main dispatcher to
		// the original Main dispatcher
		Dispatchers.resetMain()
		dispatcher.close()
	}
	
	@Test
	fun testSomeUI() = runBlocking {
		launch(Dispatchers.Main) {
		// ...
		}
	}
}
```

В Android мы обычно используем `Main` диспетчер по умолчанию.
Если вы используете библиотеки, которые приостанавливаются, а не блокируются, и вы
не делайте никаких сложных расчетов, на практике часто можно использовать только
`Dispatchers.Main`. Если вы выполняете некоторые операции с интенсивным использованием процессора, вы следует запускать их в `Dispatchers.Default`. Этих двоих достаточно для многих приложений, но что, если вам нужно заблокировать поток?
Например, если вам нужно выполнить длинные операции ввода-вывода (например, чтение
большие файлы) или если вам нужно использовать библиотеку с функциями блокировки.
Вы не можете заблокировать основной поток, поскольку ваше приложение
заморозить. Если вы заблокируете диспетчер по умолчанию, вы рискуете заблокировать все
потоки в пуле потоков, и в этом случае вы не сможете производить какие-либо расчеты. Вот почему нам нужен диспетчер для такого ситуация, и это `Dispatchers.IO`.

## IO dispatcher

`Dispatchers.IO` предназначен для использования, когда мы блокируем потоки с помощью
Операции ввода-вывода, например, когда мы читаем/записываем файлы, используем Android общие настройки или функции блокировки вызовов. Код ниже принимает
около 1 секунды, поскольку `Dispatchers.IO` допускает более 50 активных нити одновременно.

```kotlin
suspend fun main() {
	val time = measureTimeMillis {
	coroutineScope {
		repeat(50) {
			launch(Dispatchers.IO) {
				Thread.sleep(1000)
				}
			}
		}
	}
	println(time) // ~1000
}
```

Как это работает? Представьте себе неограниченный пул потоков. Изначально,
он пуст, но так как нам нужно больше потоков, они создаются и сохраняются активны до тех пор, пока они не будут использоваться в течение некоторого времени. Такой пул существует, но он было бы небезопасно использовать его напрямую. При слишком большом количестве активных потоков производительность снижается медленно, но неограниченно, в конечном итоге вызывая ошибки нехватки памяти. Для этого мы создаём диспетчеров
которые имеют ограниченное количество потоков, которые они могут использовать одновременно время. `Dispatchers.Default` ограничен количеством ядер в вашем компьютере.
процессор. Предел` Dispatchers.IO` — 64 (или количество ядер
если их больше).

```kotlin
suspend fun main() = coroutineScope {
	repeat(1000) {
		launch(Dispatchers.IO) {
			Thread.sleep(200)
			val threadName = Thread.currentThread().name
			println("Running on thread: $threadName")
		}
	}
}
// Running on thread: DefaultDispatcher-worker-1
//...
// Running on thread: DefaultDispatcher-worker-53
// Running on thread: DefaultDispatcher-worker-14
```

Как мы уже упоминали, `Dispatchers.Default` и `Dispatchers.IO`
использовать один и тот же пул потоков. Это важная оптимизация.
Потоки используются повторно, и часто повторная диспетчеризация не требуется. Для в-
Предположим, вы используете `Dispatchers.Default`, а затем выполнение достигает `withContext(Dispatchers.IO) { ... }`. Большинство часто вы остаетесь в одной и той же теме, но меняется то, что этот поток учитывается не в пределе `Dispatchers.Default`, а к пределу `Dispatchers.IO`. Их пределы независимы, поэтому они никогда не будут морить друг друга голодом.

```kotlin
suspend fun main(): Unit = coroutineScope {
	launch(Dispatchers.Default) {
	println(Thread.currentThread().name)
		withContext(Dispatchers.IO) {
			println(Thread.currentThread().name)
		}
	}
}
// DefaultDispatcher-worker-2
// DefaultDispatcher-worker-2
```

Чтобы увидеть это более ясно, представьте, что вы используете оба `Dispatchers.Default` и `Dispatchers.IO` на максимум. Как в результате количество ваших активных потоков будет суммой их пределы. Если вы разрешаете 64 потока в `Dispatchers.IO` и у вас 8
ядер, у вас будет 72 активных потока в общем пуле. Это означает у нас эффективное повторное использование потоков, и оба диспетчера имеют сильные
независимость.

Наиболее типичный случай использования `Dispatchers.IO` — это когда нам нужно для вызова функций блокировки из библиотек. Лучшая практика — обернуть их с помощью`withContext(Dispatchers.IO)`, чтобы они приостанавливались функции. Такие функции можно использовать без особой осторожности: с ними можно обращаться так же, как и со всеми другими правильно реализованными приостановками функции.

```kotlin
class DiscUserRepository(
	private val discReader: DiscReader
) : UserRepository {
	override suspend fun getUser(): UserData =
		withContext(Dispatchers.IO) {
			UserData(discReader.read("userName"))
		}
}
```

Единственная проблема — когда такие функции блокируют слишком много потоков.
`Dispatchers.IO` ограничено 64. Один сервис, который массово блокируется.
выполнение потоков может заставить всех остальных ждать своей очереди. Чтобы помочь нам справиться при этом мы снова используем `limitedParallelism`.

## Диспетчер IO с собственным пулом потоков

`Dispatchers.IO` имеет специальное поведение, определенное для `limitedParallelism`. Он создает новый диспетчер с независимый пул потоков. Более того, этот пул не
ограничено 64, так как мы можем решить ограничить его столько потоков, сколько мы хотеть.
Например, представьте, что вы запускаете 100 сопрограмм, каждая из которых блокирует
нить на секунду. Если вы запустите эти сопрограммы на`Dispatchers.IO`,
это займет 2 секунды. Если вы запустите их на `Dispatchers.IO` с помощью
`limitedParallelism` установлен на 100 потоков, это займет 1 секунду. Исполнитель-
время работы обоих диспетчеров может измеряться одновременно потому что пределы этих двух диспетчеров в любом случае независимы.

```kotlin
suspend fun main(): Unit = coroutineScope {
	launch {
		printCoroutinesTime(Dispatchers.IO)
		// Dispatchers.IO took: 2074
	}
	
	launch {
		val dispatcher = Dispatchers.IO
		.limitedParallelism(100)
		printCoroutinesTime(dispatcher)
		// LimitedDispatcher@XXX took: 1082
	}
}

suspend fun printCoroutinesTime(
	dispatcher: CoroutineDispatcher
) {
	val test = measureTimeMillis {
	coroutineScope {
		repeat(100) {
			launch(dispatcher) {
				Thread.sleep(1000)
			}
		}
	}
}
println("$dispatcher took: $test")
}
```

Концептуально это можно представить следующим образом:

```kotlin
// Dispatcher with an unlimited pool of threads
private val pool = ...
	Dispatchers.IO = pool.limitedParallelism(64)
	Dispatchers.IO.limitedParallelism(x) =
		pool.limitedParallelism(x)
```

![[Pasted image 20231227182138.png]]

`limitedParallelism`, используемый в `Dispatchers.Default` создает дополнительный
предел. Использование `LimitedParallelism` в `Dispatcher.IO` создает диспетчер независимым от `Dispatcher.IO`. Однако все они используют один и тот же бесконечный пул потоков.

Лучшая практика для классов, которые могут интенсивно блокировать потоки:
определить своих собственных диспетчеров, которые имеют свои собственные независимые лимиты. Насколько большим должен быть этот предел? Вам нужно решить для себя.
Слишком много потоков — это неэффективное использование наших ресурсов. На
с другой стороны, ожидание доступного потока вредно для производительности. Самое главное, что этот предел не зависит от `Dispatcher.IO` и ограничения других диспетчеров. Благодаря этому один сервис не будет блокировать другой.

```kotlin
class DiscUserRepository(
	private val discReader: DiscReader
) : UserRepository {
	private val dispatcher = Dispatchers.IO
		.limitParallelism(5)
		
	override suspend fun getUser(): UserData =
		withContext(dispatcher) {
			UserData(discReader.read("userName"))
		}
}
```

## Диспетчер с фиксированным пулом потоков

155

Некоторым разработчикам нравится иметь больше контроля над пулами потоков.
они используют, и Java предлагает для этого мощный API. Например, мы
может создавать фиксированный или кэшированный пул потоков с помощью `Executors`
класс. Эти пулы реализуют `ExecutorService` или `Executor` интерфейсы, которые мы можем преобразовать в диспетчер с помощью `asCoroutineDispatcher` функция.

```kotlin
val NUMBER_OF_THREADS = 20
val dispatcher = Executors
	.newFixedThreadPool(NUMBER_OF_THREADS)
	.asCoroutineDispatcher()n
```

limitedParallelism был введен в kotlinx-сопрограммы версии 1.6; в предыдущих версиях,
мы часто создавали диспетчеры с независимыми пулами потоки с использованием класса Executors.

Самая большая проблема с этим подходом заключается в том, что диспетчер создал
с `ExecutorService.asCoroutineDispatcher()` необходимо закрыть с функцией `close`. Разработчики часто забывают об этом, что приводит к утечке потоков. Другая проблема заключается в том, что когда вы создаете фиксированный пул потоков, вы не используете их эффективно. Вы будете сохраняйте неиспользуемые темы живыми, не передавая их другим сервисам.

## Диспетчер ограничен одним потоком

Для всех диспетчеров, использующих несколько потоков, нам необходимо учитывать
общая состояние проблема. Обратите внимание, что в примере ниже 10 000 корутины увеличивают i на 1. Итак, его значение должно быть 10 000, но оно
это меньшее число. Это результат общего состояния (i свойства)
модификация в нескольких потоках одновременно.

```kotlin
var i = 0
suspend fun main(): Unit = coroutineScope {
	repeat(10_000) {
		launch(Dispatchers.IO) { // or Default
			i++
		}
	}
	delay(1000)
	println(i) // ~9930
}
```

Существует множество способов решения этой проблемы (большинство будет описано
в главе «Проблема с состоянием»), но один из вариантов — использовать
диспетчер с одним потоком. Если мы используем только один поток в
времени, нам не нужна никакая другая синхронизация. Классический способ
сделать это было для создания такого диспетчера с помощью `Executors`.

```kotlin
val dispatcher = Executors.newSingleThreadExecutor()
	.asCoroutineDispatcher()
// previously:
// val dispatcher = newSingleThreadContext("My name")
```

Проблема в том, что этот диспетчер поддерживает активным дополнительный поток,
и его необходимо закрыть, когда он больше не используется. Современный
решение — использовать `Dispatchers.Default` или `Dispatchers.IO` (если мы
блокировать потоки) с параллелизмом, ограниченным до 1.

```kotlin
var i = 0
suspend fun main(): Unit = coroutineScope {
	val dispatcher = Dispatchers.Default
		.limitedParallelism(1)
		
	repeat(10000) {
		launch(dispatcher) {
			i++
		}
	}
	delay(1000)
	println(i) // 10000
}
```

Самым большим недостатком является то, что, поскольку у нас есть только один поток,
наши вызовы будут обрабатываться последовательно, если мы заблокируем их.

```kotlin
suspend fun main(): Unit = coroutineScope {
	val dispatcher = Dispatchers.Default
		.limitedParallelism(1)
		
	val job = Job()
	repeat(5) {
		launch(dispatcher + job) {
			Thread.sleep(1000)
		}
	}
	job.complete()
	val time = measureTimeMillis { job.join() }
	println("Took $time") // Took 5006
}
```

## Использование виртуальных потоков из Project Loom

Платформа JVM представила новую технологию, известную как Project Loom.
Самым большим нововведением является введение виртуальных потоков, которые
намного легче обычных потоков. Иметь его стоит гораздо дешевле блокировать виртуальные потоки, чем блокировать обычный поток.

Project Loom мало что может предложить нам, разработчикам, которые знают
Котлинские корутины. У Kotlin Coroutines есть еще много удивительных возможностей.
такие возможности, как легкая отмена или виртуальное время для тестирования. Что
Project Loom может быть действительно полезен тем, что мы можем использовать его виртуальный потоки вместо `Dispatcher.IO`, где нам не избежать блокировки потока.
Чтобы использовать Project Loom, нам нужно использовать JVM версии выше 19,
и в настоящее время нам нужно включить функции предварительного просмотра с помощью
`--enable-preview`  флаг предварительного просмотра. Тогда мы сможем создать исполнителя используя `newVirtualThreadPerTaskExecutor` из `Executors` и преобразуйте его в диспетчер сопрограмм.

```kotlin
val LoomDispatcher = Executors
	.newVirtualThreadPerTaskExecutor()
	.asCoroutineDispatcher()
```

В качестве альтернативы можно создать объект, реализующий `ExecutorCoroutineDispatcher`.

158