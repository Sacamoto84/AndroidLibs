Мы представили `Flow` как трубу, через которую проходят значения. По мере движения они могут изменяться разными способами: удаляться, умножаться, преобразовываться или объединяться. Эти операции между созданием потока и его завершением называются обработкой потока. В этой главе мы узнаем о функциях, которые мы используем для этого.

Представленные здесь функции могут напомнить вам о функциях, которые мы используем для обработки коллекций. Это не случайно, поскольку они представляют те же самые концепции, за исключением того, что элементы потока могут распространяться во времени.

## map

Первая важная функция, о которой нам нужно узнать, — это `map`, которая преобразует каждый элемент потока согласно своей функции трансформации. Если у вас есть поток чисел, и ваша операция заключается в вычислении квадратов этих чисел, то результирующий поток будет содержать квадраты этих чисел.

```kotlin
suspend fun main() {
	flowOf(1, 2, 3) // [1, 2, 3]
		.map { it * it } // [1, 4, 9]
		.collect { print(it) } // 149
}
```

![[./img/312.png]]

Я буду использовать показанные выше диаграммы для визуализации того, как функции обработки потока изменяют элементы со временем. Горизонтальная линия представляет время, а элементы на этой линии - это элементы, которые передаются в потоке в этот момент времени. Линия выше представляет поток перед представленной операцией, а линия ниже представляет поток после операции. Эта диаграмма также может использоваться для представления нескольких операций, используемых одна за другой, например, `map` и `filter` на диаграмме ниже.

![[./img/313.png]]

Большинство функций обработки потока довольно просты в реализации с использованием инструментов, которые мы уже изучили в предыдущих главах. Чтобы реализовать `map`, мы можем использовать конструктор `flow` для создания нового потока. Затем мы можем собирать элементы из предыдущего потока и передавать каждый собранный элемент с применением преобразования. Приведенная ниже реализация является немного упрощенной версией реальной реализации из библиотеки kotlinx.coroutines.

```kotlin
fun <T, R> Flow<T>.map(
	transform: suspend (value: T) -> R
): Flow<R> = flow { // here we create a new flow
	collect { value -> // here we collect from receiver
		emit(transform(value))
	}
}
```

Функция `map` является очень популярной. Ее использование включает распаковку или преобразование значений в другой тип.

```kotlin
// Here we use map to have user actions from input events
fun actionsFlow(): Flow<UserAction> =
	observeInputEvents()
		.map { toAction(it.code) }

// Here we use map to convert from User to UserJson
fun getAllUser(): Flow<UserJson> =
	userRepository.getAllUsers()
		.map { it.toUserJson() }
```

## filter

Следующая важная функция - `filter`, возвращающая поток, содержащий только те значения из исходного потока, которые соответствуют заданному предикату.

```kotlin
suspend fun main() {
	(1..10).asFlow() // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
		.filter { it <= 5 } // [1, 2, 3, 4, 5]
		.filter { isEven(it) } // [2, 4]
		.collect { print(it) } // 24
}

fun isEven(num: Int): Boolean = num % 2 == 0
```

![[./img/315.png]]

Данную функцию также можно реализовать довольно легко с помощью конструктора потока. Для этого просто необходимо использовать оператор условия if с предикатом (вместо преобразования).

```kotlin
fun <T> Flow<T>.filter(
	predicate: suspend (T) -> Boolean
): Flow<T> = flow { // here we create a new flow
	collect { value -> // here we collect from receiver
			if (predicate(value)) {
			emit(value)
		}
	}
}
```

"filter" обычно используется для удаления элементов, которые нас не интересуют.

```kotlin
// Here we use filter to drop invalid actions
fun actionsFlow(): Flow<UserAction> =
	observeInputEvents()
		.filter { isValidAction(it.code) }
		.map { toAction(it.code) }
```

## take and drop

Мы используем `take`, чтобы передать только определенное количество элементов.

```kotlin
suspend fun main() {
	('A'..'Z').asFlow()
		.take(5) // [A, B, C, D, E]
		.collect { print(it) } // ABCDE
}
```

![[./img/316.png]]

Мы используем `drop`, чтобы проигнорировать определенное количество элементов.

```kotlin
suspend fun main() {
	('A'..'Z').asFlow()
		.drop(20) // [U, V, W, X, Y, Z]
		.collect { print(it) } // UVWXYZ
}
```

![[./img/316_2.png]]

## How does collection processing work?

Мы рассмотрели несколько функций обработки потоков и функций жизненного цикла. Их реализация достаточно проста, поэтому можно сказать, что в них нет ничего магического. Большинство таких функций можно реализовать с помощью конструктора потоков и функции `collect` с лямбда-выражением. Вот простой пример обработки потоков и упрощенной реализации функций `map` и `flowOf`:

```kotlin
suspend fun main() {
	flowOf('a', 'b')
		.map { it.uppercase() }
		.collect { print(it) } // AB
}

fun <T, R> Flow<T>.map(
	transform: suspend (value: T) -> R
): Flow<R> = flow {
	collect { value ->
		emit(transform(value))
	}
}

fun <T> flowOf(vararg elements: T): Flow<T> = flow {
	for (element in elements) {
		emit(element)
	}
}
```

Если вы встроите функции `filter` и `map`, у вас получится следующий код (я добавил метки к лямбда-выражениям и комментарии с номерами).

```kotlin
suspend fun main() {
	flow map@{ // 1
		flow flowOf@{ // 2
			for (element in arrayOf('a', 'b')) { // 3
				this@flowOf.emit(element) // 4
			}
		}.collect { value -> // 5
			this@map.emit(value.uppercase()) // 6
		}
	}.collect { // 7
		print(it) // 8
	}
}
```

Давайте проанализируем это по шагам. Мы начинаем поток на шаге 1 и собираем его на шаге 7. Когда мы начинаем сбор, мы вызываем лямбду @map (которая начинается с 1), которая вызывает другой построитель на шаге 2 и собирает его на шаге 5. Когда мы собираем на шаге 5, мы запускаем лямбду @flowOn (которая начинается с 2). Эта лямбда (на шаге 2) итерирует по массиву с 'a' и 'b'. Первое значение 'a' передается на шаге 4, что вызывает лямбду на шаге 5. Эта лямбда (на шаге 5) преобразует значение в 'A' и передает его в поток @map, вызывая тем самым лямбду на шаге 7. Значение выводится на печать, затем мы завершаем лямбду на шаге 7 и продолжаем выполнение лямбды на шаге 6. Она завершается, поэтому мы продолжаем выполнение @flowOf на шаге 4. Мы продолжаем итерацию и передаем 'b' на шаге 4. Таким образом, мы вызываем лямбду на шаге 5, преобразуем значение в 'B' и передаем его на шаге 6 в поток @map. Значение собирается на шаге 7 и выводится на печать на шаге 8. Лямбда на шаге 7 завершается, поэтому мы продолжаем выполнение лямбды на шаге 6. Она завершается, затем мы продолжаем выполнение @flowOf на шаге 4. Это также завершается, поэтому мы продолжаем @map при сборе на шаге 5. Поскольку больше нет операций, мы достигаем конца @map. С этого момента мы продолжаем сбор на шаге 7 и достигаем конца основной функции. То же самое происходит в большинстве функций обработки потоков и жизненного цикла, поэтому понимание этого дает нам довольно хорошее представление о том, как работает Flow.

## merge, zip and combine

Давайте поговорим об объединении двух потоков в один. Есть несколько способов сделать это. Самый простой — объединить элементы из двух потоков в один. Никаких изменений не производится, независимо от того, из какого потока элементы исходят. Для этого мы используем функцию объединения верхнего уровня (`merge`).

```kotlin
suspend fun main() {
	val ints: Flow<Int> = flowOf(1, 2, 3)
	val doubles: Flow<Double> = flowOf(0.1, 0.2, 0.3)

	val together: Flow<Number> = merge(ints, doubles)
	print(together.toList())
	// [1, 0.1, 0.2, 0.3, 2, 3]
	// or [1, 0.1, 0.2, 0.3, 2, 3]
	// or [0.1, 1, 2, 3, 0.2, 0.3]
	// or any other combination
}
```

![[./img/319.png]]

Важно знать, что при использовании функции `merge` элементы из одного потока не ждут элементы из другого потока. Например, в приведенном ниже примере, элементы из первого потока задерживаются, но это не останавливает элементы из второго потока.

```kotlin
suspend fun main() {
	val ints: Flow<Int> = flowOf(1, 2, 3)
		.onEach { delay(1000) }
	val doubles: Flow<Double> = flowOf(0.1, 0.2, 0.3)

	val together: Flow<Number> = merge(ints, doubles)
	together.collect { println(it) }
}
// 0.1
// 0.2
// 0.3
// (1 sec)
// 1
// (1 sec)
// 2
// (1 sec)
// 3
```

Мы используем функцию `merge`, когда у нас есть несколько источников событий, которые должны привести к одинаковым действиям.

```kotlin
fun listenForMessages() {
	merge(userSentMessages, messagesNotifications)
		.onEach { displayMessage(it) }
		.launchIn(scope)
}
```

Следующая функция - `zip`, которая создает пары элементов из обоих потоков. Нам также нужно указать функцию, которая определяет, как элементы объединяются в одну пару (какой элемент будет отправлен в новый поток). Каждый элемент может быть только частью одной пары, поэтому он должен ждать своей пары. Элементы, оставшиеся без пары, теряются, поэтому когда процесс объединения потоков с помощью `zip` завершен, результирующий поток также завершается (как и другой поток).

```kotlin
suspend fun main() {
	val flow1 = flowOf("A", "B", "C")
		.onEach { delay(400) }
	val flow2 = flowOf(1, 2, 3, 4)
		.onEach { delay(1000) }
	flow1.zip(flow2) { f1, f2 -> "${f1}_${f2}" }
		.collect { println(it) }
}
// (1 sec)
// A_1
// (1 sec)
// B_2
// (1 sec)
// C_3
```

![[./img/321.png]]

Функция `zip` напоминает мне полонез - традиционный польский танец. Одна из особенностей этого танца заключается в том, что линия из пар разделяется пополам, а затем эти пары вновь объединяются, когда встречаются снова.

Последняя важная функция при объединении двух потоков - это `combine`. Как и `zip`, она также формирует пары элементов, которые должны ждать, пока более медленный поток создаст первую пару. Однако сходство с танцем полонез заканчивается здесь. При использовании `combine` каждый новый элемент заменяет своего предшественника. Если первая пара уже сформирована, она создаст новую пару вместе с предыдущим элементом из другого потока.

![[./img/322.png]]

Заметьте, что `zip` требует пары элементов, поэтому он завершает свою работу, когда закрывается первый поток. В то время как `combine` не имеет такого ограничения и будет продолжать генерировать элементы до закрытия обоих потоков.

```kotlin
suspend fun main() {
	val flow1 = flowOf("A", "B", "C")
		.onEach { delay(400) }
	val flow2 = flowOf(1, 2, 3, 4)
		.onEach { delay(1000) }
	flow1.combine(flow2) { f1, f2 -> "${f1}_${f2}" }
		.collect { println(it) }
}
// (1 sec)
// B_1
// (0.2 sec)
// C_1
// (0.8 sec)
// C_2
// (1 sec)
// C_3
// (1 sec)
// C_4
```

`combine` обычно используется, когда нам нужно активно наблюдать два источника изменений. Если вы хотите, чтобы элементы выпускались каждый раз при изменении, можно добавить начальные значения к каждому объединенному потоку (чтобы иметь начальную пару).

```kotlin
userUpdateFlow.onStart { emit(currentUser) }
```

Типичным примером использования может быть случай, когда представлению требуется отслеживать изменения одного из двух наблюдаемых элементов. Например, когда значок уведомлений зависит как от текущего состояния пользователя, так и от каких-то уведомлений, мы можем отслеживать изменения обоих и объединять их, чтобы обновлять представление.

```kotlin
userStateFlow
	.combine(notificationsFlow) { userState, notifications ->
		updateNotificationBadge(userState, notifications)
	}
	.collect()
```

## fold and scan

Если вы используете функции обработки коллекций, вам может быть знакома функция `fold`. Она используется для комбинирования всех значений в коллекции в одно значение путем применения операции, которая объединяет два значения в одно для каждого элемента (начиная с начального значения).

Например, если начальное значение равно 0, а операция - это сложение, то результатом будет сумма всех чисел: мы берем начальное значение 0; затем добавляем к нему первый элемент 1; к результату 1 мы добавляем второе число 2; к результату 3 мы добавляем третье число 3; к результату 6 мы добавляем последнее число 4. Результатом этой операции, 10, будет значение, которое вернется из `fold`.

```kotlin
fun main() {
	val list = listOf(1, 2, 3, 4)
	val res = list.fold(0) { acc, i -> acc + i }
	println(res) // 10
	val res2 = list.fold(1) { acc, i -> acc * i }
	println(res2) // 24
}
```

![[./img/324.png]]

`fold` является терминальной операцией. Ее также можно использовать для работы с потоком (`Flow`), но она приостановит выполнение до завершения этого потока (так же, как `collect`).

```kotlin
suspend fun main() {
	val list = flowOf(1, 2, 3, 4)
		.onEach { delay(1000) }
	val res = list.fold(0) { acc, i -> acc + i }
	println(res)
}
// (4 sec)
// 10
```

Есть альтернатива `fold` под названием `scan`. Это промежуточная операция, которая создает все промежуточные значения аккумулятора.

```kotlin
fun main() {
	val list = listOf(1, 2, 3, 4)
	val res = list.scan(0) { acc, i -> acc + i }
	println(res) // [0, 1, 3, 6, 10]
}
```

![[./img/325.png]]

`scan` полезен с `Flow`, потому что он генерирует новое значение непосредственно после получения предыдущего значения.

```kotlin
suspend fun main() {
	flowOf(1, 2, 3, 4)
		.onEach { delay(1000) }
		.scan(0) { acc, v -> acc + v }
		.collect { println(it) }
}
// 0
// (1 sec)
// 1
// (1 sec)
// 3
// (1 sec)
// 6
// (1 sec)
// 10
```

![[./img/326.png]]

Мы можем легко реализовать `scan`, используя конструктор `flow` и `collect`. Сначала мы передаем начальное значение, затем с каждым новым элементом мы передаем результат накопления следующего значения.

```kotlin
fun <T, R> Flow<T>.scan(
	initial: R,
	operation: suspend (accumulator: R, value: T) -> R
): Flow<R> = flow {
	var accumulator: R = initial
	emit(accumulator)
	collect { value ->
		accumulator = operation(accumulator, value)
		emit(accumulator)
	}
}
```

Типичное использование `scan` - это когда у нас есть поток обновлений или изменений, и нам нужен объект, который является результатом этих изменений.

```kotlin
val userStateFlow: Flow<User> = userChangesFlow
	.scan(user) { user, change -> user.withChange(change) }

val messagesListFlow: Flow<List<Message>> = messagesFlow
	.scan(messages) { acc, message -> acc + message }
```

## flatMapConcat, flatMapMerge and flatMapLatest

Еще одна хорошо известная функция для коллекций - `flatMap`. В случае коллекций она похожа на `map`, но функция трансформации должна возвращать коллекцию, которая затем "выпрямляется" или "сглаживается". Например, если у вас есть список отделов, в каждом из которых есть список сотрудников, вы можете использовать `flatMap`, чтобы создать список всех сотрудников из всех отделов.

```kotlin
val allEmployees: List<Employee> = departments
	.flatMap { department -> department.employees }

// If we had used map, we would have a list of lists instead
val listOfListsOfEmployee: List<List<Employee>> = departments
	.map { department -> department.employees }
```

`flatMap` в случае потока (`Flow`) действительно слегка отличается. Так как элементы потока могут быть распределены во времени, возникает вопрос: должен ли поток, созданный из второго элемента, ждать поток, созданный из первого, или же обрабатывать их параллельно? Поскольку здесь нет однозначного ответа, нет просто функции `flatMap` для `Flow`, но есть `flatMapConcat`, `flatMapMerge` и `flatMapLatest`.

Функция `flatMapConcat` обрабатывает созданные потоки один за другим. Таким образом, второй поток может начать обработку только после завершения первого. В следующем примере мы создаем поток из символов “A”, “B” и “C”. Поток, созданный каждым из них, включает эти символы и числа 1, 2 и 3 с задержкой в 1 секунду между ними.

```kotlin
fun flowFrom(elem: String) = flowOf(1, 2, 3)
	.onEach { delay(1000) }
	.map { "${it}_${elem} " }

suspend fun main() {
	flowOf("A", "B", "C")
		.flatMapConcat { flowFrom(it) }
		.collect { println(it) }
}
// (1 sec)
// 1_A
// (1 sec)
// 2_A
// (1 sec)
// 3_A
// (1 sec)
// 1_B
// (1 sec)
// 2_B
// (1 sec)
// 3_B
// (1 sec)
// 1_C
// (1 sec)
// 2_C
// (1 sec)
// 3_C
```

![[./img/329.png]]

Правильно, функция `flatMapMerge` обрабатывает созданные потоки параллельно, что действительно интуитивно понятно.

```kotlin
fun flowFrom(elem: String) = flowOf(1, 2, 3)
	.onEach { delay(1000) }
	.map { "${it}_${elem} " }

suspend fun main() {
	flowOf("A", "B", "C")
		.flatMapMerge { flowFrom(it) }
		.collect { println(it) }
}
// (1 sec)
// 1_A
// 1_B
// 1_C
// (1 sec)
// 2_A
// 2_B
// 2_C
// (1 sec)
// 3_A
// 3_B
// 3_C
```

![[./img/330.png]]

Действительно важно учитывать параметр concurrency, который определяет количество потоков, которые могут обрабатываться параллельно при использовании функции `flatMapMerge`. Значение по умолчанию для этого параметра - 16, но его можно изменить в JVM, используя свойство DEFAULT_CONCURRENCY_PROPERTY_NAME. Однако стоит быть осторожным с этим значением по умолчанию, потому что если вы используете `flatMapMerge` на потоке с большим количеством элементов, только 16 из них будут обработаны одновременно.

```kotlin
suspend fun main() {
	flowOf("A", "B", "C")
		.flatMapMerge(concurrency = 2) { flowFrom(it) }
		.collect { println(it) }
}
// (1 sec)
// 1_A
// 1_B
// (1 sec)
// 2_A
// 2_B
// (1 sec)
// 3_A
// 3_B
// (1 sec)
// 1_C
// (1 sec)
// 2_C
// (1 sec)
// 3_C
```

Типичное использование `flatMapMerge` возникает, когда нам нужно запросить данные для каждого элемента в потоке. Например, у нас есть список категорий, и нам нужно запросить предложения для каждой из них. Вы уже знаете, что это можно сделать с помощью функции `async`. Однако есть два преимущества использования потока с `flatMapMerge`:

• мы можем контролировать параметр concurrency и решать, сколько категорий мы хотим получать одновременно (чтобы избежать отправки сотен запросов одновременно); 
• мы можем вернуть поток (`Flow`) и отправлять следующие элементы по мере их поступления (таким образом, на стороне использования функции они могут быть обработаны немедленно).

```kotlin
suspend fun getOffers(
	categories: List<Category>
): List<Offer> = coroutineScope {
	categories
		.map { async { api.requestOffers(it) } }
		.flatMap { it.await() }
}

// A better solution
suspend fun getOffers(
	categories: List<Category>
): Flow<Offer> = categories
	.asFlow()
	.flatMapMerge(concurrency = 20) {
		suspend { api.requestOffers(it) }.asFlow()
		// or flow { emit(api.requestOffers(it)) }
	}
```

Последняя функция - `flatMapLatest`. Она забывает о предыдущем потоке, как только появляется новый. При каждом новом значении предыдущая обработка потока забывается. Таким образом, если между "A", "B" и "C" нет задержки, то вы увидите только "1_C", "2_C" и "3_C".

```kotlin
fun flowFrom(elem: String) = flowOf(1, 2, 3)
	.onEach { delay(1000) }
	.map { "${it}_${elem} " }

suspend fun main() {
	flowOf("A", "B", "C")
		.flatMapLatest { flowFrom(it) }
		.collect { println(it) }
}
// (1 sec)
// 1_C
// (1 sec)
// 2_C
// (1 sec)
// 3_C
```

![[./img/332.png]]

Это становится более интересным, когда элементы из исходного потока задерживаются. В приведенном ниже примере (через 1.2 секунды) элемент "A" начинает свой поток, который был создан с использованием `flowFrom`. Этот поток создает элемент "1_A" через 1 секунду, но через 200 мс появляется "B", и этот предыдущий поток закрывается и забывается. Поток "B" успевает создать "1_B", когда появляется "C" и начинает создавать свой поток. В конечном итоге он создаст элементы "1_C", "2_C" и "3_C" с задержкой в 1 секунду между ними.

```kotlin
suspend fun main() {
	flowOf("A", "B", "C")
		.onEach { delay(1200) }
		.flatMapLatest { flowFrom(it) }
		.collect { println(it) }
}
// (2.2 sec)
// 1_A
// (1.2 sec)
// 1_B
// (1.2 sec)
// 1_C
// (1 sec)
// 2_C
// (1 sec)
// 3_C
```

![[./img/333.png]]

## retry

Исключение проходит через поток, закрывая каждый этап поочередно. Эти этапы становятся неактивными, поэтому невозможно отправлять сообщения после возникновения исключения. Однако каждый этап предоставляет ссылку на предыдущие этапы, и эту ссылку можно использовать для запуска этого потока заново. На основе этой идеи Kotlin предлагает функции `retry` и `retryWhen`. Вот упрощенная реализация `retryWhen`:

```kotlin
// Simplified implementation of retryWhen
fun <T> Flow<T>.retryWhen(
	predicate: suspend FlowCollector<T>.(
		cause: Throwable,
		attempt: Long,
	) -> Boolean,
): Flow<T> = flow {
	var attempt = 0L
	do {
		val shallRetry = try {
			collect { emit(it) }
			false
		} catch (e: Throwable) {
			predicate(e, attempt++)
				.also { if (!it) throw e }
		}
	} while (shallRetry)
}
```

Как видно, у функции `retryWhen` есть предикат, который проверяется каждый раз, когда происходит исключение из предыдущих этапов потока. Этот предикат решает, должно ли исключение быть проигнорировано, и предыдущие этапы должны быть запущены заново, или же оно должно продолжить закрывать этот поток. Это универсальная функция повтора. В большинстве случаев мы хотим указать, что мы хотим повторить определенное количество раз и/или только при возникновении определенного класса исключений (например, исключения сетевого подключения). Для этого существует другая функция, называемая `retry`, которая использует `retryWhen` внутри себя.

```kotlin
// Actual implementation of retry
fun <T> Flow<T>.retry(
	retries: Long = Long.MAX_VALUE,
	predicate: suspend (cause: Throwable) -> Boolean = {true}
): Flow<T> {
	require(retries > 0) {
		"Expected positive amount of retries, but had $retries"
	}
	return retryWhen { cause, attempt ->
		attempt < retries && predicate(cause)
	}
}
```

Вот как работает функция retry:

```kotlin
suspend fun main() {
	flow {
		emit(1)
		emit(2)
		error("E")
		emit(3)
	}.retry(3) {
		print(it.message)
		true
	}.collect { print(it) } // 12E12E12E12(exception thrown)
}
```

Давайте рассмотрим несколько популярных способов использования этих функций. Часто встречаются повторные попытки, которые всегда повторяются. Для них популярной причиной определения предиката является установка логирования и введение задержки между новыми попытками подключения.

```kotlin
fun makeConnection(config: ConnectionConfig) = api
	.startConnection(config)
	.retry { e ->
		delay(1000)
		log.error(e) { "Error for $config" }
		true
	}
```

Есть еще одна популярная практика, которая включает постепенное увеличение задержки между последующими попытками подключения. Мы также можем реализовать предикат, который повторяет попытку, если исключение относится к определенному типу или наоборот, если оно не относится к определенному типу.

```kotlin
fun makeConnection(config: ConnectionConfig) = api
	.startConnection(config)
	.retryWhen { e, attempt ->
		delay(100 * attempt)
		log.error(e) { "Error for $config" }
		e is ApiException && e.code !in 400..499
	}
```
## Distinct functions

```kotlin
// Simplified distinctUntilChanged implementation
fun <T> Flow<T>.distinctUntilChanged(): Flow<T> = flow {
	var previous: Any? = NOT_SET
	collect {
		if (previous == NOT_SET || previous != it) {
			emit(it)
			previous = it
		}
	}
}

private val NOT_SET = Any()
```

Еще одна очень полезная функция - `distinctUntilChanged`, которая помогает устранить повторяющиеся элементы, считающиеся идентичными. Обратите внимание, что эта функция удаляет только элементы, которые идентичны соответствующему предыдущему элементу.

```kotlin
suspend fun main() {
	flowOf(1, 2, 2, 3, 2, 1, 1, 3)
		.distinctUntilChanged()
		.collect { print(it) } // 123213
}
```

Также существуют варианты этой функции. Первый, `distinctUntilChangedBy`, определяет селектор ключа, который будет сравниваться для проверки идентичности двух элементов. Второй вариант, `distinctUntilChanged` с лямбда-выражением, позволяет указать, как должны сравниваться два элемента (вместо стандартного метода `equals`, используемого по умолчанию).

```kotlin
data class User(val id: Int, val name: String) {
	override fun toString(): String = "[$id] $name"
}

suspend fun main() {
	val users = flowOf(
		User(1, "Alex"),
		User(1, "Bob"),
		User(2, "Bob"),
		User(2, "Celine")
	)

println(users.distinctUntilChangedBy { it.id }.toList())
// [[1] Alex, [2] Bob]
println(users.distinctUntilChangedBy{ it.name }.toList())
// [[1] Alex, [1] Bob, [2] Celine]
println(users.distinctUntilChanged { prev, next ->
prev.id == next.id || prev.name == next.name
}.toList()) // [[1] Alex, [2] Bob]
// [2] Bob was emitted,
// because we compare to the previous emitted

}
```

## Terminal operations

Наконец, у нас есть операции, завершающие обработку потока. Они называются терминальными операциями. До этого мы использовали только `collect`, но есть и другие операции, аналогичные тем, что предлагают коллекции и `Sequence`: `count` (подсчитывает количество элементов в потоке), `first` и `firstOrNull` (для получения первого элемента, излученного потоком), `fold` и `reduce` (для накопления элементов в объект). Терминальные операции приостанавливают выполнение и возвращают значение после завершения потока (или завершают поток сами по себе).

```kotlin
suspend fun main() {
	val flow = flowOf(1, 2, 3, 4) // [1, 2, 3, 4]
		.map { it * it } // [1, 4, 9, 16]

	println(flow.first()) // 1
	println(flow.count()) // 4

	println(flow.reduce { acc, value -> acc * value }) // 576
	println(flow.fold(0) { acc, value -> acc + value }) // 30
}
```

В настоящее время для потоков действительно не так много терминальных операций, но если вам нужна какая-то другая функциональность, всегда можно реализовать её самостоятельно. Например, вот как можно реализовать операцию `sum` для потока целых чисел (`Int`):

```kotlin
suspend fun Flow<Int>.sum(): Int {
	var sum = 0
	collect { value ->
		sum += value
	}
	return sum
}
```

Точно так же вы можете выполнить практически любую терминальную операцию, просто используя метод collect.
 
Существует множество инструментов, поддерживающих обработку потоков данных. Полезно иметь представление о них, поскольку они полезны как в бэкенд-разработке, так и при создании приложений под Android. Кроме того, если вам нужны какие-то другие функции, их можно легко реализовать благодаря методу `collect` и построителю потоков данных.