Поток представляет собой последовательность значений, которые вычисляются асинхронно. Сам интерфейс `Flow` позволяет только собирать текущие элементы, что означает обработку каждого элемента по мере его достижения конца потока (`collect` для `Flow` подобен `forEach` для коллекций).

```kotlin
interface Flow<out T> {
	suspend fun collect(collector: FlowCollector<T>)
}
```

Как видите, `collect` - единственная функция-член в интерфейсе `Flow`. Все остальные определены как расширения. Это похоже на `Iterable` или `Sequence`, у которых также только одна функция-член: `iterator`.

```kotlin
interface Iterable<out T> {
	operator fun iterator(): Iterator<T>
}

interface Sequence<out T> {
	operator fun iterator(): Iterator<T>
}
```

## Сравнение потока с другими способами представления значений

Концепция `Flow` должна быть хорошо знакома тем, кто использует `RxJava` или `Reactor`, но другим, возможно, потребуется более подробное объяснение. Представьте, что вам нужна функция, возвращающая несколько значений. Когда все эти значения предоставляются одновременно, мы используем коллекции, такие как `List` или `Set`.

```kotlin
fun allUsers(): List<User> =
	api.getAllUsers().map { it.toUser() }
```

Суть здесь в том, что `List` и `Set` представляют полностью вычисленные коллекции. Поскольку процесс вычисления этих значений занимает время, нам нужно подождать, пока все значения будут вычислены, прежде чем вернуть их.

```kotlin
fun getList(): List<Int> = List(3) {
	Thread.sleep(1000)
	"User$it"
}

fun main() {
	val list = getList()
	println("Function started")
	list.forEach { println(it) }
}
// (3 sec)
// Function started
// User0
// User1
// User2
```

Если элементы вычисляются поочередно, мы предпочитаем получать следующие элементы сразу по мере их появления. Один из способов сделать это - использовать `Sequence`, о котором мы уже узнали в главе о `Sequence builder`.

```kotlin
fun getSequence(): Sequence<String> = sequence {
	repeat(3) {
		Thread.sleep(1000)
		yield("User$it")
	}
}

fun main() {
	val list = getSequence()
	println("Function started")
	list.forEach { println(it) }
}
// Function started
// (1 sec)
// User0
// (1 sec)
// User1
// (1 sec)
// User2
```

Последовательности идеально подходят для представления потока значений, вычисляемых по требованию, когда их вычисление может быть ресурсоемким на процессоре (например, при вычислении сложных результатов) или блокирующим (как при чтении файлов). Однако важно знать, что терминальные операции последовательности (например, `forEach`) не приостанавливают выполнение, поэтому любая приостановка внутри построителя последовательности означает блокировку потока, ожидающего значения. Поэтому в рамках построителя `sequence` нельзя использовать ни одну приостанавливающую функцию, кроме тех, которые вызываются для получателя `SequenceScope` (например, `yield` и `yieldAll`).

```kotlin
fun getSequence(): Sequence<String> = sequence {
	repeat(3) {
		delay(1000) // Compilation error
		yield("User$it")
	}
}
```

Этот механизм был введен, чтобы предотвратить неправильное использование последовательностей. Даже если бы приведенный выше пример удалось скомпилировать, он все равно был бы некорректным, потому что терминальная операция (например, `forEach`) блокировала бы поток вместо приостанавливающей корутины, что могло бы привести к непредвиденной блокировке потока. Представьте, что кто-то хочет использовать последовательность для извлечения списков пользователей из HTTP-точки доступа пагинацией до тех пор, пока не будет получена пустая страница. Проблема в том, что любое использование такой последовательности будет блокирующим, потому что функция `iterator` в `Sequence` не является приостанавливающейся.

```kotlin
// Don't do that, we should use Flow instead of Sequence
fun allUsersSequence(
	api: UserApi
): Sequence<User> = sequence {
	var page = 0
	do {
		val users = api.takePage(page++) // suspending,
		// so compilation error
		yieldAll(users)
	} while (!users.isNullOrEmpty())
}
```

Именно такие задачи и должны решать последовательности. Они идеально подходят для источников данных большого размера (или бесконечных), где элементы могут быть сложными, и мы хотим вычислять или читать их по требованию, лениво.

```kotlin
val fibonacci: Sequence<BigInteger> = sequence {
	var first = 0.toBigInteger()
	var second = 1.toBigInteger()
	while (true) {
		yield(first)
		val temp = first
		first += second
		second = temp
	}
}

fun countCharactersInFile(path: String): Int =
	File(path).useLines { lines ->
		lines.sumBy { it.length }
	}
```

Я надеюсь, у вас уже есть представление о том, что блокировка потока может быть очень опасной и привести к непредвиденным ситуациям. Чтобы сделать это абсолютно ясным, взгляните на пример ниже. Мы используем `Sequence`, поэтому его `forEach` - это блокирующая операция. Поэтому корутина, запущенная на том же потоке с помощью `launch`, будет ожидать, и выполнение одной корутины заблокирует выполнение другой.

```kotlin
fun getSequence(): Sequence<String> = sequence {
	repeat(3) {
		Thread.sleep(1000)
		// the same result as if there were delay(1000) here
		yield("User$it")
	}
}

suspend fun main() {
	withContext(newSingleThreadContext("main")) {
		launch {
			repeat(3) {
			delay(100)
			println("Processing on coroutine")
		}
	}

	val list = getSequence()
		list.forEach { println(it) }
	}
}
// (1 sec)
// User0
// (1 sec)
// User1
// (1 sec)
// User2
// Processing on coroutine
// (0.1 sec)
// Processing on coroutine
// (0.1 sec)
// Processing on coroutine
```

Это случай, когда следует использовать `Flow` вместо `Sequence`. Такой подход полностью поддерживает корутины в своих операциях. Его построитель и операции являются приостанавливающими функциями, он поддерживает структурированный параллелизм и правильную обработку исключений. Мы рассмотрим все это в следующих главах, но пока давайте посмотрим, как это поможет в данном случае.

```kotlin
fun getFlow(): Flow<String> = flow {
	repeat(3) {
		delay(1000)
		emit("User$it")
	}
}

suspend fun main() {
	withContext(newSingleThreadContext("main")) {
		launch {
			repeat(3) {
			delay(100)
			println("Processing on coroutine")
			}
		}

		val list = getFlow()
		list.collect { println(it) }
	}
}
// (0.1 sec)
// Processing on coroutine
// (0.1 sec)
// Processing on coroutine
// (0.1 sec)
// Processing on coroutine
// (1 - 3 * 0.1 = 0.7 sec)
// User0
// (1 sec)
// User1
// (1 sec)
// User2
```

`Flow` следует использовать для потоков данных, которым необходимо использовать корутины. Например, его можно использовать для создания потока пользователей, которые запрашиваются из API постранично. Обратите внимание, что вызывающая сторона этой функции может обрабатывать поступающие страницы данных по мере их поступления и решать, сколько страниц будет запрашиваться. Например, если мы вызовем `allUsersFlow(api).first()`, мы получим только первую страницу; если мы вызовем `allUsersFlow(api).toList()`, мы получим все страницы; если мы вызовем `allUsersFlow(api).find { it.id == id }`, мы будем запрашивать страницы, пока не найдем нужную.

```kotlin
fun allUsersFlow(
	api: UserApi
): Flow<User> = flow {
	var page = 0
	do {
		val users = api.takePage(page++) // suspending
		emitAll(users)
	} while (!users.isNullOrEmpty())
}
```

## The characteristics of Flow

Терминальные операции `Flow` (например, `collect`) приостанавливают корутину вместо блокирования потока. Они также поддерживают другие функциональные возможности корутины, такие как уважение контекста корутины и обработка исключений. Обработка `Flow` может быть отменена, и структурированный параллелизм поддерживается из коробки. Построитель потока не является приостанавливающим и не требует какого-либо контекста. Это терминальная операция приостанавливает выполнение и создает связь с родительской корутиной (аналогично функции `coroutineScope`).

Приведенный ниже пример показывает, как контекст `CoroutineName` передается из `collect` в лямбда-выражение в построителе потока. Он также показывает, что отмена запущенной корутины также приводит к правильной отмене обработки потока.

```kotlin
// Notice, that this function is not suspending
// and does not need CoroutineScope
fun usersFlow(): Flow<String> = flow {
	repeat(3) {
		delay(1000)
		val ctx = currentCoroutineContext()
		val name = ctx[CoroutineName]?.name
		emit("User$it in $name")
	}
}

suspend fun main() {
	val users = usersFlow()

	withContext(CoroutineName("Name")) {
		val job = launch {
		// collect is suspending
		users.collect { println(it) }
	}

	launch {
		delay(2100)
		println("I got enough")
		job.cancel()
		}
	}
}
// (1 sec)
// User0 in Name
// (1 sec)
// User1 in Name
// (0.1 sec)
// I got enough
```

## Flow nomenclature

Каждый поток состоит из нескольких элементов:

• Поток должен начинаться откуда-то. Это часто начинается с построителя потока, преобразования из другого объекта или из некоторой вспомогательной функции. Самые важные варианты будут объяснены в следующей главе, `Flow building`.

• Последняя операция на потоке называется терминальной операцией, что очень важно, так как это часто единственная операция, которая приостанавливается или требует области видимости. Типичная терминальная операция - это collect, с лямбда-выражением или без него. Однако также существуют и другие терминальные операции. Некоторые из них будут объяснены в главе `Flow processing`.

• Между начальной операцией и терминальной операцией могут быть промежуточные операции, каждая из которых вносит какие-то изменения в поток. Мы узнаем о различных промежуточных операциях в главах `Flow lifecycle` и `Flow`.

![[./img/273.png]]

## Real-life use cases

Практика показывает, что чаще нам нужен именно поток, а не канал. Если вы запрашиваете поток данных, вероятно, вы хотите запросить его по требованию. Если вам нужно наблюдать за чем-то, таким как изменения в вашей базе данных или события из пользовательского интерфейса или сенсоров, скорее всего, вы хотите, чтобы эти события получал каждый наблюдатель. Также вам нужно прекратить прослушивание, когда никто не наблюдает. Поэтому для всех этих случаев предпочтительнее использовать поток вместо канала (хотя в некоторых случаях мы будем использовать гибрид этих двух подходов).

Самые типичные применения потоков включают:

• прием или отправку сообщений, передаваемых через Server-Sent Events, такие как WebSockets, RSocket, уведомления и т. д.; 
• наблюдение за действиями пользователей, такими как изменения текста или клики;
• получение обновлений от сенсоров или другой информации о устройстве, например, его местоположение или ориентация; • отслеживание изменений в базах данных.

Вот как мы можем отслеживать изменения в SQL-базе данных, используя библиотеку Room:

```kotlin
@Dao
interface MyDao {
	@Query("SELECT * FROM somedata_table")
	fun getData(): Flow<List<SomeData>>
}
```

Давайте рассмотрим несколько примеров использования потока для обработки потока ответов от API. Я начну с того, над которым недавно работал. Представьте торговую рабочую станцию, наподобие Bloomberg или Scanz, которая всегда показывает вам текущее состояние рынка. Поскольку рынок постоянно меняется, эти программы обновляются много раз в секунду. Это отличный случай использования потока как на серверной, так и на клиентской стороне.

![[./img/274.png]]

Более повседневным примером может быть чат или клиент, предоставляющий в реальном времени рекомендации для поиска. Например, когда мы ищем лучший рейс на SkyScanner, некоторые предложения приходят быстро, а затем постепенно появляются другие; таким образом, вы видите все более лучшие результаты. Это также отличный случай для использования потока.

Кроме указанных ситуаций, поток также полезен для обработки различных параллельных сценариев. Например, представьте, что у вас есть список продавцов, для каждого из которых вам нужно получить их предложения. Мы уже узнали, что это можно сделать, используя `async` операции внутри обработки коллекций:

```kotlin
suspend fun getOffers(
	sellers: List<Seller>
): List<Offer> = coroutineScope {
	sellers
		.map { seller ->
			async { api.requestOffers(seller.id) }
		}
		.flatMap { it.await() }
}
```

  
Данный подход правильный во многих случаях, но у него есть один недостаток:

Если список продавцов большой, отправка такого большого количества запросов сразу не будет хорошей идеей ни для нас, ни для сервера, с которого мы запрашиваем информацию. Конечно, это можно ограничить на уровне репозитория с помощью ограничителя скорости, но также мы можем хотеть контролировать это на стороне использования, для чего можно использовать поток. В этом случае, чтобы ограничить количество одновременных вызовов до 20, мы можем использовать `flatMapMerge` (одну из функций обработки потока, которую мы объясним в главе "Обработка потока") с модификатором concurrency, установленным на 20.

```kotlin
suspend fun getOffers(
	sellers: List<Seller>
): List<Offer> = sellers
	.asFlow()
	.flatMapMerge(concurrency = 20) { seller ->
		suspend { api.requestOffers(seller.id) }.asFlow()
	}
	.toList()
```

Работа с потоком вместо коллекции дает нам гораздо больший контроль над поведением конкурентности, контекстами, исключениями и многим другим. Мы узнаем об этих возможностях в следующих главах. Именно здесь (по моему опыту) поток наиболее полезен. Я надеюсь, это станет ясным, когда мы рассмотрим все его различные функциональности.

Некоторые команды предпочитают реактивный стиль программирования и поэтому используют поток вместо приостанавливающих функций. Такой стиль стал популярным на Android, где популярен был RxJava, но сейчас Flow часто рассматривается как лучшая альтернатива. В таких командах поток часто используется, когда функции возвращают только одно значение. Лично я предпочитаю использовать просто приостанавливающие функции в таких случаях, но оба подхода имеют право на жизнь.

Как видите, существует множество сценариев использования потоков. В некоторых проектах они будут использоваться часто, а в других - время от времени. Но, надеюсь, вы видите, что они полезны и стоят того, чтобы узнать о них.

В этой главе мы познакомились с концепцией Flow. Он представляет собой поток асинхронно вычисляемых значений, поддерживающий корутины (в отличие от последовательностей). Существует множество сценариев использования, где Flow полезен. Мы рассмотрим их в следующих главах, когда узнаем больше о возможностях Flow.